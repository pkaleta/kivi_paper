\documentclass[a4paper]{report}
%\usepackage{fullpage}
\usepackage{listings}
\usepackage{caption}
\usepackage{url}
%\usepackage{courier}

\begin{document}

\lstset{ %
language=Haskell,               % the language of the code
basicstyle=\ttfamily,       % the size of the fonts that are used for the code
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=2,                   % the step between two line-numbers. If it's 1, each line 
% will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
tabsize=2,                      % sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
xleftmargin=30pt,
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
title=\lstname,                 % show the filename of files included with \lstinputlisting;
escapeinside={\%*}{*)},         % if you want to add a comment within your code
morekeywords={*,...}            % if you want to add more keywords to the set
}


\title{Lazy functional programming language targeting Low Level Virtual Machine}
\author{\textit{Author:}\\Piotr Micha\l{} Kaleta\\\\\emph{Supervisor:}\\dr W\l{}odzimierz Moczurad}
\date{\today}

\maketitle
\pagenumbering{roman}

\newpage
\thispagestyle{empty}
\mbox{}

\Huge
\begin{abstract}
  \normalsize
  \center
  This paper describes the design and Haskell implementation of a lazy
  programming language called Kivi. It is higly influenced on both Haskell's
  syntax as well as the way that computations are performed. However it generates
  the \textit{Low Level Virtual Machine}\cite{website:llvm} Intermediate
  Representation code as the output, which is then assembled and compiled to
  native code by LLVM.
\end{abstract}


\renewcommand{\abstractname}{Acknowledgements}
\begin{abstract}
  \normalsize
  \center
  First of all I'd like to thank all members of my family. They have
  always helped me and stood beside me.
  \begin{flushright}
    Piotr Kaleta
  \end{flushright}
\end{abstract}

\normalsize
\pagenumbering{arabic}

\tableofcontents

\chapter{Introduction}

This paper describes the design and implementation of a lazy functional
language compiler. The implementation is based on the
\textit{G-machine}\cite{jones87} and uses \textit{lazy graph reduction} to
perform evaluation.

The compilation process is implemented as a set of passes that eventually
transforms the source code into simple intermediate language \textit{lambda
calculus} enriched with let(rec) expressions. It would be possible to implement
compiler using less passes than I did, or maybe even one, but such clear
separation made things simpler to both develop and debug as well. Besides now
the compiler is very modular and inserting additional passes could be done with
no harm, which wouldn't be that easy if I'd used one pass only instead.


In following chapters I am going to describe the process of translating
\textit{Lambda Calculus} into \textit{G-code} instructions.  Finally these
instructions will either be evaluated by the interpreter or compiled down to
LLVM intermediate representation and further to native code by LLVM
infrastructure compilers. Design and implementation of both of these concepts
will be described in separate chapters.

TODO: Opis po kolei czesci dokumentu

\section{Implementation language - Haskell}

\chapter{Parsing}

In order to translate the source of \textit{Kivi} into \textit{Lambda Calculus}
it has to be available in a structured form so thate later passes could easily
traverse it. \textit{Abstract Syntax Trees}\cite{wiki:ast} has been widely adopted as a
standard form of keeping the representation of source code in memory. The
process of reading the input source file and producing AST from it is called
\textit{parsing}.
I've chosen to implement a simple parser, in a similar manner as in
\cite{joneslester00} as it seemed as the simplest approach to me then. Now, as
the parser has grown, I'd strongly consider rewriting it to use parser combinator
library such as \cite{website:parsec} instead.  The parsing consists of two
passes. As previously mentioned such separation makes implementation and
reading the code easier. Thus parsing consist of:

\begin{itemize}
  \item Firstly \textit{lexical analysis} implemented by \texttt{lex} in
    \texttt{Lexer.hs} module extracts \textit{tokens} from plain text.
    \textit{Tokenization} is the process of demarcating and possibly
    classifying sections of a string of input characters. The resulting tokens
    are then passed on to further processing.
  \item \textit{Syntax analysis} is the process of analyzing the stream of
    tokens and building an \textit{Abstract Syntax Tree} from it.
\end{itemize}

TODO: Grammar of the language

This two-phase process is implemented as\footnote{Where \texttt{PatProgram}
is program containing patterns}:
\begin{verbatim}
parse :: String -> PatProgram
parse = syntax . lex
\end{verbatim}

\section{Lexical analysis}

The types for lexer are following:
\begin{verbatim}
type Token = String
type TokenInfo = (Int, Token)
\end{verbatim}
Where \texttt{TokenInfo} consist of line number and a token string itself.

The heart of \textit{lexical analyser} is the \texttt{lex'} function. It works
by classifying the parts of remaining input based on first characters.
Building number tokens may be a nice example of how it works:

\begin{lstlisting}[label=lex_comment,caption={Building tokens from numbers.}]
lex' (c : cs) lnum | isDigit c =
    (lnum, numToken) : lex' restCs lnum
        where
        numToken = c : takeWhile isDigit cs
        restCs = dropWhile isDigit cs
\end{lstlisting}


\section{Syntax analysis}
qwfofqw
efeqw
f

\chapter{Translation to Lambda Calculus}

In this chapter I'm going to present the process of transformation of a
high-level functional language into a simple intermediate form - \textit{lambda
calculus}. In the first part I'll show \textit{Kivi}'s syntax, its
constructs and structures. Later on the desired output form -
\textit{Lambda Calculus} will be shown. The rest of the chapter will
consist of ways to translate the first form into another.

\section{Syntax}
Source of \textit{Kivi}'s program consist of set of
\textit{supercombinators}\cite{wiki:supercombinator}. Supercombinator is an
expression consisting of either constants or other supercombinators and
doesn't contain any free variables in its body. Supercombinators might have
arguments, and those which doesn't are called \textit{constant applicative forms}
(or CAFs for short). Listing~\ref{supercombinator_ex} shows the simple
supercombinator with one argument.

\begin{lstlisting}[label=supercombinator_ex,caption={Simple supercombinator.}]
  sqr x = x * x
\end{lstlisting}

There is one special supercombinator called \textit{main}, that takes no
arguments. It is the entry point for program execution. If there's no
\textit{main} CAF present in Kivi's source, both compiler and interpreter
should issue specific error message.

\subsection{Case expressions}
The purpose of case expression is to allow the programmer to control the flow
of program execution via a multiway branch. The semantics of case is rather
simple. First, the expression under case is evaluated and then based on result,
the appriopriate execution path is chosen. Example of case expression is
presented in Listing~\ref{case_ex}.

\begin{lstlisting}[label=case_ex,caption={Fibonacci with case}]
  fib n =
  case n of
  0 -> 1;
  1 -> 1;
  n -> fib (n-1) + fib (n-2);

  main = fib 10
\end{lstlisting}

\subsection{Local bindings}
Supercombinators provides the ability to define local definitions using
\texttt{let} keyword. The scope of variables defined using \texttt{let} is
enclosed by the expression following \texttt{in} keyword. The example use of
local binding is presented in Listing~\ref{let_ex}


\begin{lstlisting}[label=let_ex,caption={Local \texttt{let} binding.}]
  sum x y = x + y;

  main =
  let x = 1
  y = 2
  in
  sum x y
\end{lstlisting}

\subsection{Recursive local bindings}
In order to define mutually recursive bindings using \texttt{let} one has to use the
special \texttt{letrec} construct as shown in Listing~\ref{factorial_letrec_ex}


\begin{lstlisting}[label=factorial_letrec_ex,caption={Factorial function using \texttt{letrec}.}]
  sum x y = x + y;

  main =
  letrec fac n =
  case n == 0 of
  True -> 1;
  False -> n * fac (n-1)
  in
  fac 5
\end{lstlisting}

\subsection{Where clauses}
Another way of creating recursive definitions is using the \texttt{where}
clause. Internally it will be translated into letrec binding. Example use of
\texttt{where} clause is shown in Listing~\ref{factorial_where_ex}

\begin{lstlisting}[label=factorial_where_ex,caption={Factorial function using \texttt{where}.}]
  main = fac 5
  where
  fac n = case n == 0 of
  True -> 1;
  False -> n * fac (n - 1)
\end{lstlisting}

\subsection{Lambda abstractions}
Functions in Kivi can be defined in two ways. The first one is the top level
supercombinators that has already been discussed. The other option is to define
them as \textit{lambda abstractions}. This concept is similar to \textit{anonymous
functions} used in imperative languages. The syntax for defining lambda
abstractions is presented in Listing~\ref{lambda_ex}.

\begin{lstlisting}[label=lambda_ex,caption={Lambda abstraction}]
  f = (\x . x * 2) 42
\end{lstlisting}

In this example the lambda abstraction which doubles the arguments value is
created and then applied to 42 yielding 84 as result.

During compilation process programs containing lambda abstractions are
transformed into their equivalents with lambda abstractions substituted for top
level supercombinators. This process is called \textit{lambda lifting} and is
described in more detail in chapter~\ref{lambda_lifting}.

\subsection{Pattern matching}

Pattern matching consists of specifying patterns to which some data should
conform and then checking to see if it does, as well as deconstructing the data
according to those patterns. So in other words, using pattern matching you can
recognize values, bind variables to those values and break structures down into
parts.
Patterns are matched in order they are defined in source code. Once a
successful branch is found, the right-hand-side expression is evaluated and
result returned. None of the following patterns is checked. If after checking
all patterns it turns out that none of them matches the argument, the error is
returned.

\begin{lstlisting}[label=pattern_matching_ex,caption={Factorial using pattern matching.}]
  fac 0 = 1
  fac n = n * fac (n - 1)
\end{lstlisting}

In Listing~\ref{pattern_matching_ex} a recursive supercombinator \texttt{fac}
calculating factorial is defined. There are two cases\footnote{To be honest
there are three cases, but for simplicity reasons we assume that
\texttt{fac} is called only for non-negative integers}. Either the
argument is 0 and then the result is 1, or argument is other than than 0 and
then we progress recursively. The factorial definition is expressed very
clearly by means of pattern matching.
Pattern matching is also very useful when it comes to dealing with data
types as we'll see in next section.

\subsection{Data Types}
Data types in Kivi are defined using \texttt{data} keyword, giving the name of
new type as well as its constructors and their arities. Together with pattern matching they
provide a very powerful mechanism for dealing with structured objects.

\begin{lstlisting}[label=data_type_ex,caption={Calculating length of list.}]
  data List = Nil 0 | Cons 2;

  length Nil = 0;
  length (Cons x xs) = 1 + length xs
\end{lstlisting}

In Listing~\ref{data_type_ex} a data type \texttt{List} is declared as well as
supercombinator calculating the length of a list by means of pattern matching.
In first case argument is pattern matched to the \texttt{Nil} constructor. If
matching succeeds it means that the list is empty, therefore its length is 0.
In next case the argument is matched to second \texttt{List} constructor, that
is \texttt{Cons}. If argument matches the \textit{tail} of the list is bound to
\texttt{xs} variable and right hand side of that branch is evaluated.

Creating footnotes is easy\footnote{Example footnote}
We explain in this section how to obtain headings
for the various sections and subsections of our
document.

\section{Lambda Calculus}

\section{Translation to Lambda Calculus}



\subsection{Headings in the `article' Document Style}

In the `article' style, the document may be divided up
into sections, subsections and subsubsections, and each
can be given a title, printed in a boldface font, simply by issuing the
appropriate command.

\bibliographystyle{alpha}
\bibliography{kivi}

\end{document}
