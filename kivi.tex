\documentclass[a4paper]{report}
%\usepackage{fullpage}
\usepackage{listings}
\usepackage{caption}
%\usepackage{courier}

\begin{document}

\lstset{ %
    language=Haskell,               % the language of the code
    basicstyle=\ttfamily,       % the size of the fonts that are used for the code
    numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
    stepnumber=2,                   % the step between two line-numbers. If it's 1, each line 
    % will be numbered
    numbersep=5pt,                  % how far the line-numbers are from the code
    showspaces=false,               % show spaces adding particular underscores
    showstringspaces=false,         % underline spaces within strings
    showtabs=false,                 % show tabs within strings adding particular underscores
    tabsize=2,                      % sets default tabsize to 2 spaces
    captionpos=b,                   % sets the caption-position to bottom
    breaklines=true,                % sets automatic line breaking
    xleftmargin=30pt,
    breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
    title=\lstname,                 % show the filename of files included with \lstinputlisting;
    escapeinside={\%*}{*)},         % if you want to add a comment within your code
    morekeywords={*,...}            % if you want to add more keywords to the set
}


\title{Lazy functional programming language targeting Low Level Virtual Machine}
\author{\textit{Author:}\\Piotr Micha\l{} Kaleta\\\\\emph{Supervisor:}\\dr W\l{}odzimierz Moczurad}
\date{\today}

\maketitle
\pagenumbering{roman}

\newpage
\thispagestyle{empty}
\mbox{}

\Huge
\begin{abstract}
\normalsize
\center
This paper describes the design and Haskell implementation of a lazy
programming language called Kivi. It is higly influenced on both Haskell's
syntax as well as the way that computations are performed. However it generates
the \textit{Low Level Virtual Machine}\cite{wiki:llvm} Intermediate
Representation code as the output, which is then assembled and compiled to
native code by LLVM.
\end{abstract}


\renewcommand{\abstractname}{Acknowledgements}
\begin{abstract}
\normalsize
\center
First of all I'd like to thank all members of my family. They have
always helped me and stood beside me.
\begin{flushright}
Piotr Kaleta
\end{flushright}
\end{abstract}

\normalsize
\pagenumbering{arabic}

\tableofcontents

\chapter{Introduction}

\section{Syntax}
Source of Kivi's program consists of set of
\textit{supercombinators}\cite{wiki:supercombinator}. Supercombinator is an
expression consisting of either constants or other supercombinators that
doesn't contain any free variables in its body. Supercombinators might have
arguments, and those which doesn't are called \textit{constant applicative forms}
(or CAFs for short). Listing~\ref{simplesc} shows the simple
supercombinator with arguments.

\begin{lstlisting}[label=simplesc,caption={Simple supercombinator.}]
sqr x = x * x
\end{lstlisting}

There is one special supercombinator called \textit{main}, that takes no
arguments. It is the entry point for program execution. If there's no
\textit{main} CAF present in Kivi's source, both compiler and interpreter
should issue specific error message.

\subsection{Local bindings}
Supercombinators provides the ability to define local definitions using \texttt{let} keyword.
The example use of local binding is presented in Listing~\ref{let}


\begin{lstlisting}[label=let,caption={Local \texttt{let} binding.}]
sum x y = x + y;

main =
    let x = 1
        y = 2
    in
        sum x y
\end{lstlisting}

\subsection{Recursive local bindings}
In order to define mutually recursive bindings using \texttt{let} one has to use the
special \texttt{letrec} construct as shown in Listing~\ref{factorial_letrec}


\begin{lstlisting}[label=factorial_letrec,caption={Factorial function using \texttt{letrec}.}]
sum x y = x + y;

main =
    letrec fac n =
        case n == 0 of
            True -> 1;
            False -> n * fac (n-1)
    in
        fac 5
\end{lstlisting}

\subsection{Where clauses}
Another way of creating recursive definitions is using the \texttt{where}
clause. Internally it will be translated into letrec binding. Example use of
\texttt{where} clause is shown in Listing~\ref{factorial_where}


\begin{lstlisting}[label=factorial_where,caption={Factorial function using \texttt{where}.}]
main = fac 5
    where
        fac n = case n == 0 of
            True -> 1;
            False -> n * fac (n-1)
\end{lstlisting}

\section{Section Headings}

Creating footnotes is easy\footnote{Example footnote}
We explain in this section how to obtain headings
for the various sections and subsections of our
document.

\subsection{Headings in the `article' Document Style}

In the `article' style, the document may be divided up
into sections, subsections and subsubsections, and each
can be given a title, printed in a boldface font, simply by issuing the
appropriate command.

\end{document}
